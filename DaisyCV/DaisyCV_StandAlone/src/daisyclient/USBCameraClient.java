/**
 * Streams frames from a ROBORIO MJPEG server.  Stream protocol logic taken from WPILIB.
 * @author Dave Sizer
 * @author Tom Clark
 * @author Ryan Cahoon
 */
package daisyclient;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.net.ConnectException;
import java.net.Socket;
import java.util.Arrays;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.imageio.ImageIO;

public class USBCameraClient implements Runnable {

	private final static byte[] MAGIC_NUMBERS = { 0x01, 0x00, 0x00, 0x00 };

	public final static int SIZE_640x480 = 0;
	public final static int SIZE_320x240 = 1;
	public final static int SIZE_160x120 = 2;

	private final static int HW_COMPRESSION = -1;

	static final int[] huffman_table_int = new int[] { 0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0A, 0x0B, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02,
			0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00,
			0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91,
			0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16,
			0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
			0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65,
			0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87,
			0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
			0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
			0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
			0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11, 0x00, 0x02, 0x01,
			0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11,
			0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42,
			0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1,
			0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
			0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65,
			0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86,
			0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
			0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
			0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
			0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA };

	static final byte[] huffman_table;

	static {
		huffman_table = new byte[huffman_table_int.length];
		for (int i = 0; i < huffman_table.length; ++i) {
			huffman_table[i] = (byte) huffman_table_int[i];
		}
	}

	private final int DEFAULT_PORT = 1180;
	private final int DEFAULT_FPS = 30;
	private final int DEFAULT_FRAME_SIZE = SIZE_640x480;
	private final int MAX_IMAGE_QUEUE_SIZE = 1;
	private int numImagesRecieved = 0;

	private static USBCameraClient instance = null;
	private Thread streamingThread = null;
	private Socket socket = null;
	private String currentHostname = null;
	private String errorMessage = null;
	private boolean isStreaming = false;
	private int currentPort, currentFrameSize, currentFPS;
	private BufferedImage currentImage = null;

	public Object frameMutex;
	
	public static USBCameraClient getInstance() {
		if (instance == null)
			instance = new USBCameraClient();
		return instance;
	}

	private USBCameraClient() {
		currentPort = DEFAULT_PORT;
		currentFrameSize = DEFAULT_FRAME_SIZE;
		currentFPS = DEFAULT_FPS;
		frameMutex = new Object();
	}

	public BufferedImage getLatestFrame() {
		return currentImage;
	}

	public String getLastError() {
		return errorMessage;
	}

	// Must be one of the sizes defined in this class (they are public)
	public void setFrameSize(int size) {
		switch (size) {
		case SIZE_640x480:
		case SIZE_320x240:
		case SIZE_160x120:
			currentFrameSize = size;
			break;
		default:
			currentFrameSize = DEFAULT_FRAME_SIZE;
			break;
		}
	}

	public void setFPS(int fps) {
		currentFPS = fps;
	}

	public void startStreaming(String serverHostname, int port) {
		if (isStreaming)
			return;

		streamingThread = new Thread(this);
		streamingThread.start();
		isStreaming = true;
		this.currentHostname = serverHostname;
	}

	public void startStreaming(String serverHostname) {
		startStreaming(serverHostname, DEFAULT_PORT);
	}

	public void stopStreaming() {
		if (!isStreaming)
			return;

		isStreaming = false;
	}

	public void run() {
		try {
			this.socket = new Socket(currentHostname, currentPort);
			System.out.println("Connected to " + currentHostname);
			while (!Thread.interrupted()) {
				// Check if we should still be streaming
				if (!isStreaming)
					break;
				
				DataInputStream inputStream = new DataInputStream(this.socket.getInputStream());
				DataOutputStream outputStream = new DataOutputStream(this.socket.getOutputStream());

				/* Send the request */
				outputStream.writeInt(currentFPS);
				outputStream.writeInt(HW_COMPRESSION);
				outputStream.writeInt(currentFrameSize);
				outputStream.flush();

				/* Get the response from the robot */
				/*
				 * Each frame has a header with 4 magic bytes and the number of
				 * bytes in the image
				 */
				byte[] magic = new byte[4];
				inputStream.read(magic, 0, 4);
				int size = inputStream.readInt();
				
				assert Arrays.equals(magic, MAGIC_NUMBERS);

				/*
				 * Get the image data itself, and make sure that it's a valid
				 * JPEG image (it starts with [0xff,0xd8] and ends with
				 * [0xff,0xd9]
				 */
				byte[] data = new byte[size + huffman_table.length];
				inputStream.readFully(data, 0, size);

				assert size >= 4 && (data[0] & 0xff) == 0xff && (data[1] & 0xff) == 0xd8
						&& (data[size - 2] & 0xff) == 0xff && (data[size - 1] & 0xff) == 0xd9;
				;

				int pos = 2;
				boolean has_dht = false;
				while (!has_dht) {
					assert pos + 4 <= size;
					assert (data[pos] & 0xff) == 0xff;

					if ((data[pos + 1] & 0xff) == 0xc4)
						has_dht = true;
					else if ((data[pos + 1] & 0xff) == 0xda)
						break;

					// Skip to the next marker.
					int marker_size = ((data[pos + 2] & 0xff) << 8) + (data[pos + 3] & 0xff);
					pos += marker_size + 2;
				}
				if (!has_dht) {
					System.arraycopy(data, pos, data, pos + huffman_table.length, size - pos);
					System.arraycopy(huffman_table, 0, data, pos, huffman_table.length);
					size += huffman_table.length;
				}
				/* Decode the data and push the image to the queue */
				
				BufferedImage thisFrame = ImageIO.read(new ByteArrayInputStream(data));
				currentImage = thisFrame;
                
				
				System.out.println(numImagesRecieved++);

				this.errorMessage = null;
			}
		} catch (ConnectException e) {
			if (this.errorMessage == null) {
				this.errorMessage = "Could not connect to the TCP server";
			}
		} catch (EOFException e) {
			if (this.errorMessage == null) {
				this.errorMessage = "Robot stopped returning images";
			}
		} catch (IOException e) {
			if (this.errorMessage == null) {
				this.errorMessage = "Could not connect to the TCP server";
			}
		} finally {
			if (this.socket != null) {
				try {
					this.socket.close();
				} catch (IOException e) {
				}
			}
			try {
				Thread.sleep((int) (1000 / currentFPS));
			} catch (InterruptedException e1) {
			}
		}
	}
}
